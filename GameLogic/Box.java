package GameLogic;

import Utility.FunctionLogger;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : 6projlab
//  @ File Name : Box.java
//  @ Date : 2018.03.17.
//  @ Author : Gyöngyösi Péter
//
//



/* Moveable-bõl leszármazõ doboz osztály */
public class Box extends Thing implements Moveable{
	
	/* Doboz elpusztítása.
	 * Lekérdezi a mezõt, amelyiken a doboz áll, majd törli 
	 * a fieldrõl és a raktárból. 
	 * */
	public void Destroy() {
		FunctionLogger.logFunctionCalled("Field", "Remove()");
		GetField().Remove();
		FunctionLogger.logFunctionCalled("Warehouse", "Remove()");
		GetField().GetWarehouse().RemoveBox(this);
		FunctionLogger.logFunctionReturnVoid();
	}
	
	/* Doboz adott irányba mozgatása 
	 * Visszaaja hogy a doboz elmozdult-e. A szomszédos mezõn 
	 * álló dologgal ütközteti a dobozt. Ha mozoghat, a szomszédos
	 * mezõre lépteti.
	 */
	public boolean Move(Direction dir) {
		FunctionLogger.logFunctionCalled("FieldNeighbor", "HitBy(dir, this)");
		boolean hitBy = GetField().GetNeighbor(dir).HitBy(dir, this);
		if(hitBy) {
			FunctionLogger.logFunctionCalled("Field", "Remove()");
			GetField().Remove();
			FunctionLogger.logFunctionCalled("FieldNeighbor", "Add(this)");
			GetField().GetNeighbor(dir).Add(this);
			return FunctionLogger.logFunctionRetrun(true);
		}
		return FunctionLogger.logFunctionRetrun(false);
	}
	
	/* Doboznak adott irányba másik doboz ütközik.
	 * Visszaadja, hogy a másik doboz mozoghat-e az adott irányba.
	 * Ha be van ragadva hamissal, ha nincs, elmozgatja a dobozt az adott irányba,
	 * ha mozoghat arra igazzal tér vissza. 
	 */
	public boolean HitBy(Direction dir, Box b) {
		FunctionLogger.logFunctionCalled("BoxThis", "isStucked()");
		boolean stucked = isStucked();
		if(stucked) {
			FunctionLogger.logFunctionCalled("BoxHitBy", "CheckStucked(dir)");
			b.CheckStucked(dir);			
			return FunctionLogger.logFunctionRetrun(false);
		}
		else {
			FunctionLogger.logFunctionCalled("BoxThis", "Move(dir)");
			return FunctionLogger.logFunctionRetrun(Move(dir));
		}
	}
	
	/* Doboznak adott irányba munkás ütközik.
	 * Ha a doboz be van ragadva hamissal, ha nincs, akkor, a mozgatás
	 * utáni mozgás eredényével tér vissza. 
	 */
	public boolean HitBy(Direction dir, Worker w) {
		FunctionLogger.logFunctionCalled("BoxThis", "isStucked()");
		boolean stucked = isStucked();
		if(stucked) { 
			return FunctionLogger.logFunctionRetrun(false);
		}
		else {
			FunctionLogger.logFunctionCalled("BoxThis", "Move(dir)");
			return FunctionLogger.logFunctionRetrun(Move(dir));
		}
	}
	
	/* A doboz beragadottságának ellenõrzése az adott irányba. 
	 * 
	 */
	public void CheckStucked(Direction dir) {
		if(dir == Direction.Left || dir == Direction.Right)
		{
			FunctionLogger.logFunctionCalled("ThingUpNeighbor", "isStucked(");
			boolean stuckedUp   = GetField().GetNeighbor(Direction.Up).GetThing().isStucked();
			FunctionLogger.logFunctionCalled("ThingDownNeighbor", "isStucked(");
			boolean stuckedDown = GetField().GetNeighbor(Direction.Down).GetThing().isStucked();
			if(stuckedUp || stuckedDown)
				SetStucked(true);
		}
		else // if(dir == Direction.Up || dir == Direction.Down)
		{
			FunctionLogger.logFunctionCalled("ThingLeftNeighbor", "isStucked(");
			boolean stuckedLeft   = GetField().GetNeighbor(Direction.Up).GetThing().isStucked();
			FunctionLogger.logFunctionCalled("ThingRightNeighbor", "isStucked(");
			boolean stuckedRight = GetField().GetNeighbor(Direction.Down).GetThing().isStucked();
			if(stuckedLeft || stuckedRight)
				SetStucked(true);
		}
		FunctionLogger.logFunctionReturnVoid();
	}
	
}
